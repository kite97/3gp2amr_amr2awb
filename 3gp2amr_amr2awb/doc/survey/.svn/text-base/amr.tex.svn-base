%!Tex Program = xelatex
\documentclass[11pt]{article}
\usepackage{fontspec}
\usepackage{xeCJK}
\setmainfont[Mapping=tex-text,BoldFont=WenQuanYi Zen Hei]{WenQuanYi Zen Hei}
\begin{document}
\section{AMR总论}
\subsection{AMR适用范围及相关标准}
AMR全称为自适应多速率音频编码(Adaptive Multi-Rate (AMR or AMR-NB or GSM-AMR) audio codec)，
是一种音频编码方法，主要用于语音（speech coding）的编码和压缩。于1999年被3GPP定为
标准，现在被广泛使用。当时定义的AMR频宽(带宽)并不高，现在称之为AMR-NB(窄带AMR，AMR Narrowband)，
可以编码200-3400Hz范围之内的音频。相关标准见3GPP TS 26.071、3GPP TS 26.090。后经
扩展，可以编码50-7000Hz范围内的音频，现称之为AMR-WB(宽带AMR，AMR Wideband)。AMR-WB
由3GPP引入，并由ITU-T G.722.2标准化。AMR的最新标准是AMR-WB+（扩展宽带AMR，Extended AMR Wideband），
本文档不作讨论。
\subsection{AMR的数据处理模式}
AMR-NB定义的原始音频是以8000Hz进行采样，每采样13bit。原始码速率是104kbit/s，与
G.711相同。采样过后，以20ms为一个帧（frame），也就是每160个采样进行处理。经过选择可选参数的编码算法
处理，可以将一帧处理为不同大小数据。每一种参数选择称之为一种“模式”，AMR-NB总共有
8种模式。对于任意一个帧，同种模式的处理结果具有相同长度；
对于相同的帧，不同模式的处理结果具有不同长度。因为帧的时间长度均为20ms，所以可以换
算为不同的速率，一般情况下，用速率称呼不同模式。AMR-NB的8种模式为：4.75kbit/s、 5.15kbit/s、 5.9kbit/s、
6.7kbit/s、 7.4kbit/s、 7.95kbit/s、 10.2kbit/s和12.2kbit/s。在实际使用中，发送
端可以不断的调整每一帧数据的速率，来实现适应网络质量并同时达到尽可能高的语音质量
的要求。有关于AMR-NB的数据处理的详细说明，参见3GPP标准(http://www.3gpp.org/DynaReport/26071.htm,
http://www.3gpp.org/DynaReport/26090.htm)

AMR-WB与AMR-NB的数据处理方法在结构和结果上类似，但具体数据不同。AMR-WB的原始数据
以16000Hz进行采样，每采样14bit，相应的，每一帧有320个采样。而最终的模式共有9种，分别为：6.60kbit/s、 8.85kbit/s、
12.65kbit/s、 14.25kbit/s、 15.85kbit/s、 18.25kbit/s、 19.85kbit/s、 23.05kbit/s、
23.85kbit/s。有关于AMR-WB的数据处理的详细说明，参见ITU-T G.722.2（https://www.itu.int/rec/T-REC-G.722.2/en）。

\subsection{AMR的数据存储}
AMR的存储有两种容器格式可以使用，一种是AMR的专有容器，一种是MPEG的通用数据容器。
本文暂不讨论MPEG的通用容器。

AMR-NB文件的扩展名一般是.amr或.amr-nb，AMR-WB文件的扩展名一般是.awb或.amr-wb。
其内部具有相同的文件结构，但具体数值不同。文件结构如下：

\begin{verbatim}
+------------------+
| Header           |
+------------------+
| Speech frame 1   |
+------------------+
: ...              :
+------------------+
| Speech frame n   |
+------------------+
\end{verbatim}

其中，AMR-NB的头为0x2321414d520a，即是字符“\#!AMR{\textbackslash}n”，AMR-WB的头为0x2321414d522d57420a，
即是字符“\#!AMR-WB{\textbackslash}n”。AMR的头还有其也可能，用于标识多声道的情况，本方暂不讨论。

头部之后，是连续不断的所有的音频帧。每一个帧的结构如下：
\begin{verbatim}
0                   1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|P|  FT   |Q|P|P|                                               |
+-+-+-+-+-+-+-+-+                                               +
|                                                               |
+          Speech bits for frame-block n                        +
|                                                               |
+                                                           +-+-+
|                                                           |P|P|
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
\end{verbatim}

每一个帧由一个8bit的帧头引导，之后是音频数据。其中，P是填充位，填0，FT共4bit，
用于指出此帧的模式，Q位有1bit，是帧质量标识位。

有关于所有数据项具体的取值方法及意义，参见ietf 4867。（注意：AMR的存储结构由
ietf 4867定义，但真正的帧结构由3gpp ts 26系列的101和201定义，其具体每一位的含意有
细微差别，由于本文重点不在数据处理，而在于读取文件，故以ietf 4867为蓝本。）现简
述如下：每一帧的FT(frame type)值根据头的不同，分别可以取所对应的模式，AMR-NB为
0-7共8种，AMR-WB为0-8共9种。除了模式之处，FT还可以取值NO\_DATA(15)或SPEECH\_LOST(14,
AMR-WB only)，用于表示一些特殊的帧，使块(block)完整。块结构后文讲解RTP时详述。除
此之处，其他的AMR的帧，如噪声等，均不存储于文件。Q位是质量位，具体意义后文RTP时详
述，整体上来说，文件中的Q位应该均取值为1。文件中真正音频数据中图中speech bits的位
置，具体长度可以由文件头和FT唯一确定。下表是每个AMR的长度以及其中的有效位的长度：

\begin{verbatim}
+-------------------------------+
|            AMR-NB             |
+-------------------------------+
|  FT |  速率  | 有效位 |  字节 |
+-------------------------------+
|  0  |  4.75  |  95    |  13   |
+-------------------------------+
|  1  |  5.15  |  103   |  14   |
+-------------------------------+
|  2  |  5.90  |  118   |  16   |
+-------------------------------+
|  3  |  6.70  |  134   |  18   |
+-------------------------------+
|  4  |  7.40  |  148   |  19   |
+-------------------------------+
|  5  |  7.95  |  159   |  21   |
+-------------------------------+
|  6  |  10.2  |  204   |  26   |
+-------------------------------+
|  7  |  12.2  |  244   |  31   |
+-------------------------------+
|            AMR-WB             |
+-------------------------------+
|  FT |  速率  | 有效位 |  字节 |
+-------------------------------+
|  0  | 6.60   |  132   |  18   |
+-------------------------------+
|  1  | 8.85   |  177   |  23   |
+-------------------------------+
|  2  | 12.65  |  253   |  33   |
+-------------------------------+
|  3  | 14.25  |  285   |  37   |
+-------------------------------+
|  4  | 15.85  |  317   |  41   |
+-------------------------------+
|  5  | 18.25  |  365   |  47   |
+-------------------------------+
|  6  | 19.85  |  397   |  51   |
+-------------------------------+
|  7  | 23.05  |  461   |  59   |
+-------------------------------+
|  8  | 23.85  |  477   |  61   |
+-------------------------------+
\end{verbatim}

\subsection{AMR的RTP传输}
使用RTP传输AMR数据颇为复杂，主要原因是为了配全AMR的自适应能力，并且设定的
场景基本上是实时数据采集并同时编码，打包，发送。本文重点的观注点是将AMR文件
的内容使用RTP传输，故重点放在理解整体方式，选择适合工作的部分进行说明。

RTP传输AMR，是以一个“帧块”(frame-block)为单位进行传输的。帧块的概念用于多
声道，当有多个声道同时传输时，AMR将同一个时间片上的所有帧打在同一个RTP包中
进行传输。这些帧所在包中第n个位置，对应于相应的是第n个声道。因为结构更具通用性
所以单声道的AMR虽然只有一个帧，但其概念仍然是一个帧块。AMR对于RTP头的使用，只需
特别注意一点，当传输第一个包含语音的包时，mark位置为1，其余均无特别要求。RTP头
之后，是AMR的具体数据。AMR的具体数据可以用两种不同的模式进行装载，一种是承载
效率(Bandwidth-Efficient Mode)模式，一种是字节对齐(Octet-Aligned Mode)模式。其中第
一种比较简单，第二种比较复杂，但也增加了如冗余校验等更多的功能。本文以放音为目的，
选择第一种调研。AMR的RTP结构如下：
\begin{verbatim}
+----------------+-------------------+----------------
| payload header | table of contents | speech data ...
+----------------+-------------------+----------------
\end{verbatim}
其中，header部分是一个4bit的无符号整数值，叫做CMR。用于与对端动态协商AMR的速率，
由于我们不做速率协商，不做过多说明，填成15即可。
第二部分简称TOC，是一系列如下图所示的小单元组成，
\begin{verbatim}
0 1 2 3 4 5
+-+-+-+-+-+-+
|F|  FT   |Q|
+-+-+-+-+-+-+
\end{verbatim}
第一位是标识头，如果这个小单元是TOC中的最后一个，则取0，否则取1。FT用于指示对应
的语音数据的速率，Q位是质量位，因为我们不做数据采集，所以一般取为1，表示数据有效。
这些小单元的数量，与其后的语音数据是相等的，指示也是一一对应的。TOC之后，是所有
语音数据连续写入，直到最后，补0直至字节对齐。示例：
\begin{verbatim}
0                   1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| CMR=15|1| FT=0  |1|1| FT=9  |1|1| FT=15 |1|0| FT=1  |1|d(0)   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                         d(131)|
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|g(0)                                                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          g(39)|h(0)                                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                           h(176)|P|P|P|P|P|P|P|
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
\end{verbatim}
示例中共有4个帧，外部协商为AMR-WB，速率类型分别是0，9，15，1。所以第一帧有
132位，第4帧有177位。原例为了说明，用了特殊类型9（静音检测）和15（无数据），其中
9有40bit，15无内容。在最后补齐了7个bit。

\subsection{AMR的SDP协商}

AMR的SDP协商规定于IETF RFC 4867第8节，具体细节参考文档，本文重点摘要与简单
放音有关的部分。

AMR的交互可以定义若干重要参数，而这些参数都是可以在SDP中进行协商的，如模式集
合（mode set）等。这些参数的协商过程是发起端将参数置于fmtp段之后，表示请求，
响应端根据自身给出结果。如果响应端有任何不明的指示，或是不支持的，应该在响应信息
里去掉。针对于普通放音，重要的参数是模式集（mode set）和最大封包时长（maxptime）。
模式集指的是所有的AMR的帧中，可以使用的速率集合，如2，3，4，最大封包时长指的是
一个RTP包中，最多可以封装多少个帧，用时间表示，一般取20，指20毫秒，AMR-NB可以封
装160个帧块，AMR-WB可以封装320个帧块。以下示例：

请求：

\begin{verbatim}
m=audio 49120 RTP/AVP 97 98 99
a=rtpmap:97 AMR/8000/1
a=fmtp:97 mode-set=0,2,5,7
a=rtpmap:98 AMR/8000/1
a=fmtp:98 mode-set=0,2,3,6
a=rtpmap:99 AMR/8000/1
a=fmtp:99 mode-set=0,2,3,4; xxx=123
a=maxptime:20
\end{verbatim}

响应：

\begin{verbatim}
m=audio 33456 RTP/AVP 98 99
a=rtpmap:98 AMR/8000/1
a=fmtp:98 mode-set=0,2,3,6
a=rtpmap:99 AMR/8000/1
a=fmtp:99 mode-set=0,2,3,4
a=maxptime:20
\end{verbatim}

上例请求方申请了AMR-NB的语音通道，并指定了三种RTP的承载类型，分别可以使用
（0，2，5，7），（0，2，3，6），（0，2，3，4）三种模式集，并有一个非标准参数xxx，
最大封包时长是20毫秒。响应方不支持模式5，所以去掉了97，因为不理解xxx，所以不支持。

请求：

\begin{verbatim}
m=audio 49120 RTP/AVP 99 98
a=rtpmap:98 AMR-WB/16000
a=fmtp:98 mode-set=1,3,5,7
a=rtpmap:99 AMR-WB/16000
a=fmtp:99 mode-set=2,4,6,8
\end{verbatim}


响应：

\begin{verbatim}
m=audio 49120 RTP/AVP 99
a=rtpmap:99 AMR-WB/16000
a=fmtp:99 mode-set=2,4,6,8
a=maxptime:100
\end{verbatim}

上例请求了AMR-WB的语音通道，并指定两种模式集合，同时未明确maxptime，响应
明确了支持其中一种模式集合，同时协商了最大的封包时长。

\subsection{AMR的编解码工具}

AMR可以直接使用的编解码工具是 ffmpeg 和 sox，以及在这两个工具之上建立起的其他工具。
但是AMR的编解码方案似乎因为版权问题而没有简单的统一的开源代码。其中ffmpeg只支持
AMR-NB和AMR-WB的解码，sox则支持AMR-NB的编解码和AMR-WB的解码。这两个开源工具都
依赖一个开源库 opencore，其来自于 android，并且使用 apache 开源协议。而AMR-WB的编
码则可以使用另一个开源库 VisualOn。

以上各开源方案均可得到代码并实际测试，功能正确，性能看起来也不差。未来如果需要
集成的话，即可以使用外连库，也可以集中生成转换列表进行快速转换。

\end{document}
